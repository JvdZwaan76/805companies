// Complete Enhanced Cloudflare Worker for 805 LifeGuard API
// Version 3.0 - Complete Admin + Client Portal with Full D1 Integration
import { hash, verify, generateToken, verifyToken } from './utils/auth.js';

// Enhanced CORS configuration
const CORS_HEADERS = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Requested-With',
    'Access-Control-Allow-Credentials': 'false',
    'Access-Control-Max-Age': '86400'
};

// =============================================================================
// üîê AUTHENTICATION FUNCTIONS
// =============================================================================

async function handleLogin(request, env) {
    try {
        const { email, password } = await request.json();

        if (!email || !password) {
            return createErrorResponse('Email and password are required', 400);
        }

        console.log(`üîê Login attempt for: ${email}`);

        // Get user from database
        const user = await env.DB.prepare('SELECT * FROM users WHERE email = ?')
            .bind(email.toLowerCase().trim()).first();

        if (!user) {
            await new Promise(resolve => setTimeout(resolve, 100));
            return createErrorResponse('Invalid credentials', 401);
        }

        // Verify password
        const isValid = await verify(password, user.password_hash);
        if (!isValid) {
            return createErrorResponse('Invalid credentials', 401);
        }

        // Generate JWT token
        const token = await generateToken({ 
            userId: user.id, 
            email: user.email,
            name: user.name,
            userType: user.user_type || 'client'
        }, env.JWT_SECRET);

        console.log(`‚úÖ Successful login for user: ${user.email} (ID: ${user.id})`);

        return new Response(JSON.stringify({
            success: true,
            token,
            user: {
                id: user.id,
                name: user.name,
                email: user.email,
                phone: user.phone,
                address: user.address,
                emergency_contact: user.emergency_contact,
                member_since: user.member_since || user.created_at,
                user_type: user.user_type || 'client'
            }
        }), {
            status: 200,
            headers: { 'Content-Type': 'application/json' }
        });

    } catch (error) {
        console.error('Login error:', error);
        return createErrorResponse('Login failed', 500);
    }
}

async function handleAdminLogin(request, env) {
    try {
        const { username, password } = await request.json();

        if (!username || !password) {
            return createErrorResponse('Username and password are required', 400);
        }

        console.log(`üõ°Ô∏è Admin login attempt for: ${username}`);

        // Check for admin user - first try by username, then by email
        let admin = await env.DB.prepare('SELECT * FROM users WHERE username = ? AND user_type = "admin"')
            .bind(username.toLowerCase().trim()).first();
        
        if (!admin) {
            admin = await env.DB.prepare('SELECT * FROM users WHERE email = ? AND user_type = "admin"')
                .bind(username.toLowerCase().trim()).first();
        }

        if (!admin) {
            // If no admin exists, create default admin for demo
            if (username === 'admin' && password === 'admin123') {
                try {
                    const hashedPassword = await hash('admin123');
                    const result = await env.DB.prepare(`
                        INSERT INTO users (
                            username, email, name, password_hash, user_type, 
                            created_at, updated_at
                        ) VALUES (?, ?, ?, ?, 'admin', datetime('now'), datetime('now'))
                    `).bind(
                        'admin',
                        'admin@805lifeguard.com',
                        'Administrator',
                        hashedPassword
                    ).run();

                    admin = {
                        id: result.meta.last_row_id,
                        username: 'admin',
                        email: 'admin@805lifeguard.com',
                        name: 'Administrator',
                        user_type: 'admin',
                        password_hash: hashedPassword
                    };

                    console.log('‚úÖ Created default admin user');
                } catch (createError) {
                    console.error('Error creating admin:', createError);
                    return createErrorResponse('Invalid admin credentials', 401);
                }
            } else {
                await new Promise(resolve => setTimeout(resolve, 100));
                return createErrorResponse('Invalid admin credentials', 401);
            }
        }

        // Verify password
        const isValid = await verify(password, admin.password_hash);
        if (!isValid) {
            return createErrorResponse('Invalid admin credentials', 401);
        }

        // Generate admin JWT token
        const token = await generateToken({ 
            userId: admin.id, 
            email: admin.email,
            name: admin.name,
            username: admin.username,
            userType: 'admin'
        }, env.JWT_SECRET);

        console.log(`‚úÖ Successful admin login for: ${admin.username} (ID: ${admin.id})`);

        return new Response(JSON.stringify({
            success: true,
            token,
            admin: {
                id: admin.id,
                username: admin.username,
                name: admin.name,
                email: admin.email,
                user_type: 'admin'
            }
        }), {
            status: 200,
            headers: { 'Content-Type': 'application/json' }
        });

    } catch (error) {
        console.error('Admin login error:', error);
        return createErrorResponse('Admin login failed', 500);
    }
}

// =============================================================================
// üë§ USER PROFILE ENDPOINTS
// =============================================================================

async function getUserProfile(request, env) {
    const user = await authenticateRequest(request, env);
    if (!user) {
        return createErrorResponse('Unauthorized', 401);
    }

    try {
        console.log(`üìä Loading profile for user: ${user.userId}`);
        
        const userData = await env.DB.prepare(`
            SELECT id, email, name, phone, address, user_type, emergency_contact, 
                   member_since, created_at, updated_at
            FROM users 
            WHERE id = ?
        `).bind(user.userId).first();

        if (!userData) {
            return createErrorResponse('User not found', 404);
        }

        const [totalBookings, upcomingBookings, thisMonthBookings] = await Promise.all([
            env.DB.prepare('SELECT COUNT(*) as count FROM bookings WHERE user_id = ?')
                .bind(user.userId).first(),
            env.DB.prepare('SELECT COUNT(*) as count FROM bookings WHERE user_id = ? AND booking_date >= date("now")')
                .bind(user.userId).first(),
            env.DB.prepare('SELECT COUNT(*) as count FROM bookings WHERE user_id = ? AND booking_date >= date("now", "start of month")')
                .bind(user.userId).first()
        ]);

        return new Response(JSON.stringify({
            success: true,
            user: {
                id: userData.id,
                name: userData.name,
                email: userData.email,
                phone: userData.phone,
                address: userData.address,
                emergency_contact: userData.emergency_contact,
                member_since: userData.member_since || userData.created_at,
                user_type: userData.user_type || 'client',
                stats: {
                    total: totalBookings?.count || 0,
                    upcoming: upcomingBookings?.count || 0,
                    thisMonth: thisMonthBookings?.count || 0,
                    memberSince: new Date(userData.member_since || userData.created_at).getFullYear()
                },
                preferences: {
                    email_booking_confirm: true,
                    email_booking_reminder: true,
                    email_newsletter: false,
                    sms_booking_reminder: false,
                    sms_emergency: true,
                    timezone: 'America/Los_Angeles'
                }
            }
        }), {
            headers: { 'Content-Type': 'application/json' }
        });

    } catch (error) {
        console.error('Get profile error:', error);
        return createErrorResponse('Failed to load profile', 500);
    }
}

async function updateUserProfile(request, env) {
    const user = await authenticateRequest(request, env);
    if (!user) {
        return createErrorResponse('Unauthorized', 401);
    }

    try {
        const { name, phone, address, emergency_contact } = await request.json();

        if (!name || !name.trim()) {
            return createErrorResponse('Name is required', 400);
        }

        await env.DB.prepare(`
            UPDATE users 
            SET name = ?, phone = ?, address = ?, emergency_contact = ?, updated_at = datetime('now')
            WHERE id = ?
        `).bind(name.trim(), phone || null, address || null, emergency_contact || null, user.userId).run();

        console.log(`‚úÖ Profile updated for user: ${user.userId}`);

        return new Response(JSON.stringify({
            success: true,
            message: 'Profile updated successfully'
        }), {
            headers: { 'Content-Type': 'application/json' }
        });

    } catch (error) {
        console.error('Update profile error:', error);
        return createErrorResponse('Failed to update profile', 500);
    }
}

async function getUserStats(request, env) {
    const user = await authenticateRequest(request, env);
    if (!user) return createErrorResponse('Unauthorized', 401);

    try {
        const [totalBookings, upcomingBookings, thisMonthBookings] = await Promise.all([
            env.DB.prepare('SELECT COUNT(*) as count FROM bookings WHERE user_id = ?')
                .bind(user.userId).first(),
            env.DB.prepare('SELECT COUNT(*) as count FROM bookings WHERE user_id = ? AND booking_date >= date("now")')
                .bind(user.userId).first(),
            env.DB.prepare('SELECT COUNT(*) as count FROM bookings WHERE user_id = ? AND booking_date >= date("now", "start of month")')
                .bind(user.userId).first()
        ]);
        
        return new Response(JSON.stringify({
            success: true,
            stats: {
                total: totalBookings?.count || 0,
                upcoming: upcomingBookings?.count || 0,
                thisMonth: thisMonthBookings?.count || 0,
                memberSince: 2024
            }
        }), {
            headers: { 'Content-Type': 'application/json' }
        });
        
    } catch (error) {
        console.error('Stats error:', error);
        return createErrorResponse('Failed to load stats', 500);
    }
}

// =============================================================================
// üìã BOOKING ENDPOINTS
// =============================================================================

async function getBookings(request, env) {
    const user = await authenticateRequest(request, env);
    if (!user) return createErrorResponse('Unauthorized', 401);
    
    try {
        const bookings = await env.DB.prepare(`
            SELECT * FROM bookings 
            WHERE user_id = ? 
            ORDER BY booking_date DESC, booking_time DESC
        `).bind(user.userId).all();

        return new Response(JSON.stringify({
            success: true,
            bookings: bookings.results.map(booking => ({
                id: booking.id,
                service: booking.service_type,
                serviceName: booking.service_name,
                date: booking.booking_date,
                time: booking.booking_time,
                duration: booking.duration,
                participants: booking.participants,
                status: booking.status,
                cost: booking.cost,
                createdAt: booking.created_at
            }))
        }), {
            headers: { 'Content-Type': 'application/json' }
        });
    } catch (error) {
        console.error('Get bookings error:', error);
        return createErrorResponse('Failed to load bookings', 500);
    }
}

async function getUpcomingBookings(request, env) {
    const user = await authenticateRequest(request, env);
    if (!user) return createErrorResponse('Unauthorized', 401);
    
    try {
        const upcomingBookings = await env.DB.prepare(`
            SELECT * FROM bookings 
            WHERE user_id = ? AND booking_date >= date("now") 
            ORDER BY booking_date ASC, booking_time ASC 
            LIMIT 10
        `).bind(user.userId).all();
        
        return new Response(JSON.stringify({
            success: true,
            bookings: upcomingBookings.results.map(booking => ({
                id: booking.id,
                service: booking.service_type,
                serviceName: booking.service_name,
                date: booking.booking_date,
                time: booking.booking_time,
                duration: booking.duration,
                participants: booking.participants,
                status: booking.status
            }))
        }), {
            headers: { 'Content-Type': 'application/json' }
        });
        
    } catch (error) {
        console.error('Upcoming bookings error:', error);
        return createErrorResponse('Failed to load upcoming bookings', 500);
    }
}

async function createBooking(request, env) {
    const user = await authenticateRequest(request, env);
    if (!user) return createErrorResponse('Unauthorized', 401);

    try {
        const bookingData = await request.json();
        console.log('üìù Creating booking for user:', user.userId, bookingData);
        
        const result = await env.DB.prepare(`
            INSERT INTO bookings (
                user_id, service_type, service_name, booking_date, booking_time, 
                duration, participants, special_requests, status, cost, created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, 'pending', 0, datetime("now"), datetime("now"))
        `).bind(
            user.userId,
            bookingData.service,
            bookingData.serviceName || bookingData.service,
            bookingData.date,
            bookingData.time,
            parseFloat(bookingData.duration) || 1,
            parseInt(bookingData.participants) || 1,
            bookingData.specialRequests || null
        ).run();

        const bookingId = result.meta.last_row_id;

        console.log(`‚úÖ Booking created successfully: ID ${bookingId} for user ${user.userId}`);

        return new Response(JSON.stringify({
            success: true,
            booking: {
                id: bookingId,
                user_id: user.userId,
                service: bookingData.service,
                serviceName: bookingData.serviceName || bookingData.service,
                date: bookingData.date,
                time: bookingData.time,
                duration: parseFloat(bookingData.duration) || 1,
                participants: parseInt(bookingData.participants) || 1,
                status: 'pending'
            },
            message: 'Booking created successfully'
        }), {
            status: 201,
            headers: { 'Content-Type': 'application/json' }
        });

    } catch (error) {
        console.error('Booking creation error:', error);
        return createErrorResponse('Failed to create booking', 500);
    }
}

// =============================================================================
// üìÖ AVAILABILITY ENDPOINTS
// =============================================================================

async function getMonthAvailability(request, env) {
    try {
        const { year, month } = await request.json();
        
        if (!year || !month) {
            return createErrorResponse('Year and month are required', 400);
        }
        
        console.log(`üìÖ Loading availability: ${year}-${month.toString().padStart(2, '0')}`);
        
        const daysInMonth = new Date(year, month, 0).getDate();
        const availability = {};
        
        const startDate = `${year}-${month.toString().padStart(2, '0')}-01`;
        const endDate = `${year}-${month.toString().padStart(2, '0')}-${daysInMonth.toString().padStart(2, '0')}`;
        
        const bookingsResult = await env.DB.prepare(`
            SELECT booking_date, service_type, duration, status
            FROM bookings 
            WHERE booking_date BETWEEN ? AND ? AND status != 'cancelled'
        `).bind(startDate, endDate).all();
        
        const monthBookings = bookingsResult.results || [];
        
        for (let day = 1; day <= daysInMonth; day++) {
            const currentDate = new Date(year, month - 1, day);
            const dateKey = currentDate.toISOString().split('T')[0];
            
            if (currentDate < new Date().setHours(0, 0, 0, 0)) {
                availability[dateKey] = {
                    status: 'past',
                    available: 0,
                    booked: 0,
                    total: 0
                };
                continue;
            }
            
            if (currentDate.getDay() === 0) {
                availability[dateKey] = {
                    status: 'closed',
                    available: 0,
                    booked: 0,
                    total: 0,
                    reason: 'Closed Sundays'
                };
                continue;
            }
            
            const dayBookings = monthBookings.filter(b => b.booking_date === dateKey);
            const bookedHours = dayBookings.reduce((sum, booking) => sum + (booking.duration || 1), 0);
            
            const totalHours = 8;
            const availableHours = Math.max(0, totalHours - bookedHours);
            
            let status = 'available';
            if (availableHours === 0) status = 'unavailable';
            else if (availableHours < 2) status = 'limited';
            
            availability[dateKey] = {
                status,
                available: availableHours,
                booked: bookedHours,
                total: totalHours,
                bookingCount: dayBookings.length
            };
        }
        
        return new Response(JSON.stringify({
            success: true,
            availability,
            month: `${year}-${month.toString().padStart(2, '0')}`,
            totalDays: daysInMonth
        }), {
            headers: { 'Content-Type': 'application/json' }
        });
        
    } catch (error) {
        console.error('Month availability error:', error);
        return createErrorResponse('Failed to load month availability', 500);
    }
}

async function getTimeSlots(request, env) {
    try {
        const { date, service, duration } = await request.json();
        
        if (!date || !service) {
            return createErrorResponse('Date and service are required', 400);
        }
        
        const serviceConfigs = {
            'swim-lesson': {
                hours: [9, 10, 11, 14, 15, 16, 17],
                increment: 30,
                maxConcurrent: 2,
                defaultDuration: 1
            },
            'lifeguard': {
                hours: [8, 10, 12, 14, 16, 18],
                increment: 60,
                maxConcurrent: 1,
                defaultDuration: 4
            },
            'event': {
                hours: [10, 12, 14, 16, 18],
                increment: 60,
                maxConcurrent: 1,
                defaultDuration: 6
            }
        };
        
        const config = serviceConfigs[service];
        if (!config) {
            return createErrorResponse('Invalid service type', 400);
        }
        
        const requestedDuration = parseFloat(duration) || config.defaultDuration;
        
        const existingBookings = await env.DB.prepare(`
            SELECT booking_time, duration, status
            FROM bookings 
            WHERE booking_date = ? AND service_type = ? AND status != 'cancelled'
        `).bind(date, service).all();
        
        const bookedTimes = existingBookings.results?.map(b => ({
            time: b.booking_time,
            duration: b.duration || 1
        })) || [];
        
        const formatTime24To12 = (hour, minute = 0) => {
            const period = hour >= 12 ? 'PM' : 'AM';
            const displayHour = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
            const displayMinute = minute.toString().padStart(2, '0');
            return `${displayHour}:${displayMinute} ${period}`;
        };
        
        const slots = [];
        const today = new Date();
        const isToday = new Date(date).toDateString() === today.toDateString();
        const currentHour = today.getHours();
        
        config.hours.forEach(hour => {
            if (isToday && hour <= currentHour) return;
            
            if (config.increment === 30) {
                [0, 30].forEach(minute => {
                    const timeStr = formatTime24To12(hour, minute);
                    slots.push({
                        time: timeStr,
                        hour,
                        minute,
                        available: true,
                        duration: requestedDuration
                    });
                });
            } else {
                const timeStr = formatTime24To12(hour, 0);
                slots.push({
                    time: timeStr,
                    hour,
                    minute: 0,
                    available: true,
                    duration: requestedDuration
                });
            }
        });
        
        return new Response(JSON.stringify({
            success: true,
            slots: slots,
            totalSlots: slots.length,
            service: { type: service, duration: requestedDuration },
            date
        }), {
            headers: { 'Content-Type': 'application/json' }
        });
        
    } catch (error) {
        console.error('Time slots error:', error);
        return createErrorResponse('Failed to generate time slots', 500);
    }
}

// =============================================================================
// üõ°Ô∏è ADMIN ENDPOINTS
// =============================================================================

async function getAdminProfile(request, env) {
    const user = await authenticateRequest(request, env);
    if (!user || user.userType !== 'admin') {
        return createErrorResponse('Admin access required', 401);
    }

    try {
        const adminData = await env.DB.prepare(`
            SELECT id, username, email, name, user_type, created_at, updated_at
            FROM users 
            WHERE id = ? AND user_type = 'admin'
        `).bind(user.userId).first();

        if (!adminData) {
            return createErrorResponse('Admin not found', 404);
        }

        return new Response(JSON.stringify({
            success: true,
            admin: {
                id: adminData.id,
                username: adminData.username,
                name: adminData.name,
                email: adminData.email,
                user_type: adminData.user_type
            }
        }), {
            headers: { 'Content-Type': 'application/json' }
        });

    } catch (error) {
        console.error('Get admin profile error:', error);
        return createErrorResponse('Failed to load admin profile', 500);
    }
}

async function getCustomers(request, env) {
    const user = await authenticateRequest(request, env);
    if (!user || user.userType !== 'admin') {
        return createErrorResponse('Admin access required', 401);
    }

    try {
        console.log('üë• Admin loading all customers');

        const customers = await env.DB.prepare(`
            SELECT 
                u.id, u.name, u.email, u.phone, u.address, u.emergency_contact,
                u.member_since, u.created_at,
                COUNT(b.id) as total_bookings,
                COALESCE(SUM(CASE WHEN b.cost IS NOT NULL THEN b.cost ELSE 0 END), 0) as total_spent
            FROM users u
            LEFT JOIN bookings b ON u.id = b.user_id
            WHERE u.user_type = 'client' OR u.user_type IS NULL
            GROUP BY u.id, u.name, u.email, u.phone, u.address, u.emergency_contact, u.member_since, u.created_at
            ORDER BY u.created_at DESC
        `).all();

        console.log(`‚úÖ Loaded ${customers.results.length} customers for admin`);

        return new Response(JSON.stringify({
            success: true,
            customers: customers.results.map(customer => ({
                id: customer.id,
                name: customer.name || 'N/A',
                email: customer.email,
                phone: customer.phone || 'N/A',
                address: customer.address || 'N/A',
                emergency_contact: customer.emergency_contact || 'N/A',
                total_bookings: customer.total_bookings || 0,
                total_spent: customer.total_spent || 0,
                member_since: customer.member_since || customer.created_at
            }))
        }), {
            headers: { 'Content-Type': 'application/json' }
        });

    } catch (error) {
        console.error('Get customers error:', error);
        return createErrorResponse('Failed to load customers', 500);
    }
}

async function getAdminBookings(request, env) {
    const user = await authenticateRequest(request, env);
    if (!user || user.userType !== 'admin') {
        return createErrorResponse('Admin access required', 401);
    }

    try {
        console.log('üìã Admin loading all bookings');

        const bookings = await env.DB.prepare(`
            SELECT 
                b.*, 
                u.name as customer_name, 
                u.email as customer_email,
                u.phone as customer_phone
            FROM bookings b
            LEFT JOIN users u ON b.user_id = u.id
            ORDER BY b.booking_date DESC, b.booking_time DESC
        `).all();

        console.log(`‚úÖ Loaded ${bookings.results.length} bookings for admin`);

        return new Response(JSON.stringify({
            success: true,
            bookings: bookings.results.map(booking => ({
                id: booking.id,
                user_id: booking.user_id,
                service: booking.service_type,
                serviceName: booking.service_name || booking.service_type,
                date: booking.booking_date,
                time: booking.booking_time,
                duration: booking.duration || 1,
                participants: booking.participants || 1,
                status: booking.status,
                cost: booking.cost || 0,
                special_requests: booking.special_requests,
                created_at: booking.created_at,
                customer: {
                    name: booking.customer_name || 'Unknown Customer',
                    email: booking.customer_email || 'N/A',
                    phone: booking.customer_phone || 'N/A'
                }
            }))
        }), {
            headers: { 'Content-Type': 'application/json' }
        });

    } catch (error) {
        console.error('Get admin bookings error:', error);
        return createErrorResponse('Failed to load bookings', 500);
    }
}

async function updateBookingStatus(request, env, bookingId) {
    const user = await authenticateRequest(request, env);
    if (!user || user.userType !== 'admin') {
        return createErrorResponse('Admin access required', 401);
    }

    try {
        const { status } = await request.json();
        
        if (!status || !['pending', 'confirmed', 'completed', 'cancelled'].includes(status)) {
            return createErrorResponse('Invalid status', 400);
        }

        console.log(`üìã Admin updating booking ${bookingId} status to: ${status}`);

        const result = await env.DB.prepare(`
            UPDATE bookings 
            SET status = ?, updated_at = datetime('now')
            WHERE id = ?
        `).bind(status, bookingId).run();

        if (result.changes === 0) {
            return createErrorResponse('Booking not found', 404);
        }

        console.log(`‚úÖ Booking ${bookingId} status updated to ${status}`);

        return new Response(JSON.stringify({
            success: true,
            message: `Booking status updated to ${status}`
        }), {
            headers: { 'Content-Type': 'application/json' }
        });

    } catch (error) {
        console.error('Update booking status error:', error);
        return createErrorResponse('Failed to update booking status', 500);
    }
}

async function getBookingStats(request, env) {
    const user = await authenticateRequest(request, env);
    if (!user || user.userType !== 'admin') {
        return createErrorResponse('Admin access required', 401);
    }

    try {
        console.log('üìä Admin loading booking statistics');

        const [totalBookings, pendingBookings, confirmedBookings, completedBookings, 
               totalRevenue, monthlyRevenue, totalCustomers, newCustomersThisMonth] = await Promise.all([
            env.DB.prepare('SELECT COUNT(*) as count FROM bookings').first(),
            env.DB.prepare('SELECT COUNT(*) as count FROM bookings WHERE status = "pending"').first(),
            env.DB.prepare('SELECT COUNT(*) as count FROM bookings WHERE status = "confirmed"').first(),
            env.DB.prepare('SELECT COUNT(*) as count FROM bookings WHERE status = "completed"').first(),
            env.DB.prepare('SELECT COALESCE(SUM(cost), 0) as total FROM bookings WHERE status IN ("confirmed", "completed")').first(),
            env.DB.prepare('SELECT COALESCE(SUM(cost), 0) as total FROM bookings WHERE status IN ("confirmed", "completed") AND booking_date >= date("now", "start of month")').first(),
            env.DB.prepare('SELECT COUNT(*) as count FROM users WHERE user_type = "client" OR user_type IS NULL').first(),
            env.DB.prepare('SELECT COUNT(*) as count FROM users WHERE (user_type = "client" OR user_type IS NULL) AND created_at >= date("now", "start of month")').first()
        ]);

        const stats = {
            bookings: {
                total: totalBookings?.count || 0,
                pending: pendingBookings?.count || 0,
                confirmed: confirmedBookings?.count || 0,
                completed: completedBookings?.count || 0
            },
            revenue: {
                total: totalRevenue?.total || 0,
                monthly: monthlyRevenue?.total || 0
            },
            customers: {
                total: totalCustomers?.count || 0,
                newThisMonth: newCustomersThisMonth?.count || 0
            }
        };

        console.log('‚úÖ Booking statistics loaded for admin');

        return new Response(JSON.stringify({
            success: true,
            stats
        }), {
            headers: { 'Content-Type': 'application/json' }
        });

    } catch (error) {
        console.error('Get booking stats error:', error);
        return createErrorResponse('Failed to load booking statistics', 500);
    }
}

async function exportData(request, env) {
    const user = await authenticateRequest(request, env);
    if (!user || user.userType !== 'admin') {
        return createErrorResponse('Admin access required', 401);
    }

    try {
        const url = new URL(request.url);
        const type = url.searchParams.get('type') || 'bookings';

        console.log(`üì§ Admin exporting ${type} data`);

        if (type === 'customers') {
            const customers = await env.DB.prepare(`
                SELECT 
                    u.id, u.name, u.email, u.phone, u.address, u.emergency_contact,
                    u.member_since, u.created_at,
                    COUNT(b.id) as total_bookings,
                    COALESCE(SUM(b.cost), 0) as total_spent
                FROM users u
                LEFT JOIN bookings b ON u.id = b.user_id
                WHERE u.user_type = 'client' OR u.user_type IS NULL
                GROUP BY u.id
                ORDER BY u.created_at DESC
            `).all();

            const csvData = generateCustomersCSV(customers.results);
            
            return new Response(csvData, {
                headers: {
                    'Content-Type': 'text/csv',
                    'Content-Disposition': 'attachment; filename="805-lifeguard-customers.csv"',
                    ...CORS_HEADERS
                }
            });
        } else {
            // Default: export bookings
            const bookings = await env.DB.prepare(`
                SELECT 
                    b.*, 
                    u.name as customer_name, 
                    u.email as customer_email,
                    u.phone as customer_phone
                FROM bookings b
                LEFT JOIN users u ON b.user_id = u.id
                ORDER BY b.booking_date DESC, b.booking_time DESC
            `).all();

            const csvData = generateBookingsCSV(bookings.results);
            
            return new Response(csvData, {
                headers: {
                    'Content-Type': 'text/csv',
                    'Content-Disposition': 'attachment; filename="805-lifeguard-bookings.csv"',
                    ...CORS_HEADERS
                }
            });
        }

    } catch (error) {
        console.error('Export data error:', error);
        return createErrorResponse('Failed to export data', 500);
    }
}

function generateCustomersCSV(customers) {
    const headers = ['ID', 'Name', 'Email', 'Phone', 'Address', 'Emergency Contact', 'Total Bookings', 'Total Spent', 'Member Since'];
    const rows = customers.map(customer => [
        customer.id,
        customer.name || '',
        customer.email,
        customer.phone || '',
        customer.address || '',
        customer.emergency_contact || '',
        customer.total_bookings || 0,
        customer.total_spent || 0,
        customer.member_since || customer.created_at
    ]);
    
    return [headers, ...rows].map(row => 
        row.map(field => `"${String(field).replace(/"/g, '""')}"`).join(',')
    ).join('\n');
}

function generateBookingsCSV(bookings) {
    const headers = ['ID', 'Customer Name', 'Customer Email', 'Service', 'Date', 'Time', 'Duration', 'Participants', 'Status', 'Cost', 'Special Requests', 'Created At'];
    const rows = bookings.map(booking => [
        booking.id,
        booking.customer_name || '',
        booking.customer_email || '',
        booking.service_name || booking.service_type,
        booking.booking_date,
        booking.booking_time,
        booking.duration || 1,
        booking.participants || 1,
        booking.status,
        booking.cost || 0,
        booking.special_requests || '',
        booking.created_at
    ]);
    
    return [headers, ...rows].map(row => 
        row.map(field => `"${String(field).replace(/"/g, '""')}"`).join(',')
    ).join('\n');
}

// =============================================================================
// üîß HELPER FUNCTIONS
// =============================================================================

function createErrorResponse(message, status = 500, details = null) {
    const errorResponse = {
        success: false,
        error: message,
        status,
        timestamp: new Date().toISOString()
    };

    if (details) Object.assign(errorResponse, details);

    return new Response(JSON.stringify(errorResponse), {
        status,
        headers: {
            'Content-Type': 'application/json',
            ...CORS_HEADERS
        }
    });
}

async function authenticateRequest(request, env) {
    try {
        const authHeader = request.headers.get('Authorization');
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
            return null;
        }

        const token = authHeader.split(' ')[1];
        if (!token) return null;

        return await verifyToken(token, env.JWT_SECRET);
    } catch (error) {
        console.error('Authentication error:', error.message);
        return null;
    }
}

async function checkRateLimit(env, ip, path, method) {
    try {
        // Simple rate limiting - allow all requests for now
        return { allowed: true, requestCount: 0, limit: 100 };
    } catch (error) {
        console.error('Rate limiting error:', error);
        return { allowed: true, requestCount: 0, limit: 100 };
    }
}

// =============================================================================
// MAIN FETCH HANDLER WITH COMPLETE ROUTING
// =============================================================================

export default {
    async fetch(request, env, ctx) {
        const startTime = Date.now();
        const url = new URL(request.url);
        const path = url.pathname;
        const method = request.method;
        const clientIP = request.headers.get('CF-Connecting-IP') || 'unknown';

        // Enhanced CORS preflight handling
        if (method === 'OPTIONS') {
            console.log(`üîÑ CORS preflight request for ${path}`);
            return new Response(null, { 
                status: 204,
                headers: CORS_HEADERS 
            });
        }

        // Log incoming request
        console.log(`üì® ${method} ${path} from ${clientIP}`);

        try {
            let response;

            // Rate limiting check
            const rateLimitResult = await checkRateLimit(env, clientIP, path, method);
            if (!rateLimitResult.allowed) {
                console.log(`üö´ Rate limit exceeded for ${clientIP} on ${path}`);
                return createErrorResponse('Rate limit exceeded. Please try again later.', 429);
            }

            // COMPLETE ENHANCED ROUTE HANDLING
            if (path === '/api/auth/login' && method === 'POST') {
                response = await handleLogin(request, env);
            } else if (path === '/api/user/stats' && method === 'GET') {
                response = await getUserStats(request, env);
            } else if (path === '/api/user/profile' && method === 'GET') {
                response = await getUserProfile(request, env);
            } else if (path === '/api/user/profile' && method === 'PUT') {
                response = await updateUserProfile(request, env);
            } else if (path === '/api/bookings' && method === 'GET') {
                response = await getBookings(request, env);
            } else if (path === '/api/bookings' && method === 'POST') {
                response = await createBooking(request, env);
            } else if (path === '/api/bookings/upcoming' && method === 'GET') {
                response = await getUpcomingBookings(request, env);
            } else if (path === '/api/availability' && method === 'POST') {
                response = await getMonthAvailability(request, env);
            } else if (path === '/api/availability/slots' && method === 'POST') {
                response = await getTimeSlots(request, env);
            // üõ°Ô∏è ADMIN ROUTES
            } else if (path === '/api/admin/login' && method === 'POST') {
                response = await handleAdminLogin(request, env);
            } else if (path === '/api/admin/profile' && method === 'GET') {
                response = await getAdminProfile(request, env);
            } else if (path === '/api/admin/customers' && method === 'GET') {
                response = await getCustomers(request, env);
            } else if (path === '/api/admin/bookings' && method === 'GET') {
                response = await getAdminBookings(request, env);
            } else if (path === '/api/admin/bookings/stats' && method === 'GET') {
                response = await getBookingStats(request, env);
            } else if (path.startsWith('/api/admin/bookings/') && method === 'PUT') {
                const bookingId = path.split('/').pop();
                response = await updateBookingStatus(request, env, bookingId);
            } else if (path === '/api/admin/export' && method === 'GET') {
                response = await exportData(request, env);
            } else {
                response = createErrorResponse('Not Found', 404);
            }

            // Add enhanced CORS headers to all responses
            Object.entries(CORS_HEADERS).forEach(([key, value]) => {
                response.headers.set(key, value);
            });

            // Log response timing
            const duration = Date.now() - startTime;
            console.log(`‚úÖ ${method} ${path} completed in ${duration}ms`);

            return response;

        } catch (error) {
            const duration = Date.now() - startTime;
            console.error(`‚ùå ${method} ${path} failed after ${duration}ms:`, error);
            
            // Enhanced error response with CORS
            return createErrorResponse(
                'Internal Server Error', 
                500, 
                { 
                    error: 'Internal Server Error',
                    message: 'Something went wrong',
                    timestamp: new Date().toISOString(),
                    requestId: crypto.randomUUID()
                }
            );
        }
    }
};
